#pragma config(StandardModel, "RVW CLAWBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Single Sensor Line Track for Time
This program uses 1 VEX Line Follower Sensor to track a black line on a light(er) surface
for 10 seconds. There is a two second pause at the beginning of the program.

The threshold variable defined in this program may need to be changed for the line/surface your
robot is tracking and the lighting conditions.

Robot Model(s): Squarebot

[I/O Port]          [Name]              [Type]                [Description]
Motor Port 2        rightMotor          VEX Motor             Right side motor
Motor Port 3        leftMotor           VEX Motor             Left side motor
Analog Port 1       lightSensor         VEX Line Follower     Front-center, facing down

*To run this sample program on Swervebot, be sure to Reverse Motor Port 3 in the Motors and Sensors
 Setup, and to make sure that Motor Port 2 is NOT Reversed.
----------------------------------------------------------------------------------------------------*/
// Sahil Patel (159-065-176

// all distance in cm
#define CIR 28.8 // circumference
#define ARC_DEGREE 0.24 // angle per degree for turning
#define ENCODER_PULSE 360 // pulse per revolution
#define THRESHOLD 1000
#define MOVE_SPEED 50

void ahead (float distance) {
float rev = distance / CIR; // revolution required
int pulse = ENCODER_PULSE * rev; // encoder pulse required

SensorValue[leftEncoder] = 0; // reset encoder value

	while(SensorValue[leftEncoder] < pulse) // move while pulse not reached
	{
		motor[rightMotor] = 60; // speed might affect dynamics if changed
		motor[leftMotor] = 60;
	}
} // end of ahead function

void turnLeft(float angle) {
float distance = angle * ARC_DEGREE; // arc distance required
float rev = distance / CIR; // revolution required
int pulse = ENCODER_PULSE * rev; // encoder pulse required

SensorValue[rightEncoder] = 0; // reset encoder value

	while(SensorValue[rightEncoder] < pulse) // move while pulse not reached
	{
		motor[rightMotor] = 60; // speed might affect dynamics if changed
		motor[leftMotor] = -60;
	}
} // end of turnLeft function

void turnRight(float angle) {
float distance = angle * ARC_DEGREE; // arc distance required
float rev = distance / CIR; // revolution required
int pulse = ENCODER_PULSE * rev; // encoder pulse required

SensorValue[leftEncoder] = 0; // reset encoder value

	while(SensorValue[leftEncoder] < pulse) // move while pulse not reached
	{
		motor[rightMotor] =-60; // speed might affect dynamics if changed
		motor[leftMotor] = 60;
	}
}
void findLine() {
	while (SensorValue[centerLineFollower] < THRESHOLD) {
		// don't see line
		ahead(1);
	}
} // end of findLine function


int keepGoing(){
int notEnd = 1;
if (SensorValue[centerLineFollower] > THRESHOLD && SensorValue[leftLineFollower] > THRESHOLD && SensorValue[rightLineFollower] > THRESHOLD)
notEnd = 0;
return notEnd;
}


void pidMove(int controlVar){
		motor[rightMotor] = MOVE_SPEED + controlVar;
		motor[leftMotor] = MOVE_SPEED - controlVar;
} // end of pidMove function


void followLine() {
int setPoint = THRESHOLD;
//int error = 0;
int last_error = 0;
//int threshold = 1000;
float output = 0;
int derivative = 0;
float integral = 0;
//double pidOutput = 0;

const float K_p = 2.5 * pow(10, -4);
const float K_i = 0 * pow(10, 4);
const float K_d = 4 * pow(10, 3);

while(keepGoing())
{
int error = SensorValue[centerLineFollower] - setPoint;

integral += error;

derivative = error - last_error;
derivative = derivative > 100 ? 100 : (derivative < -100 ? -100 : derivative);


float p_term = K_p * error;
float i_term = K_i * integral;
float d_term = K_d * derivative;

float adjustment = p_term + i_term + d_term;

output += adjustment;

output = output > 100 ? 100 : (output < -100 ? -100 : output);

last_error = error;

pidMove((int)output);

} // end of while loop
} // end of followLine function

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
int state = 0;

while (1) {

switch (state) {
	case 0: ahead(46); state = 1; break;
	case 1: findLine(); state = 2; stopAllMotors(); break;
	case 2: turnRight(20); state = 3; stopAllMotors(); break;
	case 3: followLine(); state = 4; stopAllMotors(); break;
	case 4: turnLeft(10); state = 3; stopAllMotors(); break;
//turnRight
}

// end of switch case
} // end of while loop
} // end of main
